empty:
  in: ""
  out: ""
    
at_code:
  in: "some @strange < code@"
  out: "<p>some <code>strange &lt; code</code></p>"
  
at_code_ruby:
  in: "some @ruby|class << self@"
  out: "<p>some <code class='ruby'><span class=\"keyword\">class </span><span class=\"punct\">&lt;&lt;</span> <span class=\"constant\">self</span></code></p>"
  
code_ruby:
  in: |
    some text
  
    <code lang='ruby'>def hello
      puts "hello" << " world!"
    end</code>
  out: "/some text.*<pre>.*<code class='ruby'>.*keyword.*method.*&lt;&lt;/"

code_params:
  in:  "this <code onclick='nasty' class='blue' lang='ruby' style='tagada'>def ok</code> ok"
  out: "<p>this <pre onclick='nasty' class='blue' style='tagada'><code class='ruby'><span class=\"keyword\">def </span><span class=\"method\">ok</span></code></pre> ok</p>"
  
gallery:
  in: "this ![12,13]! gallery"
  out: "<p>this [make_gallery |12,13|] gallery</p>"

gallery_children:
  in: "this ![]! gallery"
  out: "<p>this [make_gallery ||] gallery</p>"
  
docs:
  in: "these !{11,12}! docs"
  out: "<p>these [list_nodes ids:|11,12| style:||] docs</p>"
  
docs_no_ids:
  in: "these !{}! docs"
  out: "<p>these [list_nodes ids:|| style:||] docs</p>"

docs_align:
  in: "these !<.{11,12}! left"
  out: "<p>these [list_nodes ids:|11,12| style:|&lt;.|] left</p>"
  
image:
  in: "look here !12!"
  out: "<p>look here [make_image id:|12| images:true style:||]</p>"
  
image_no_image:
  in: "look here !12!"
  out: "<p>look here [make_image id:|12| images:false style:||]</p>"

image_align:
  in: "an image !<.12!"
  out: "<p>an image [make_image id:|12| images:true style:|&lt;.|]</p>"
  
image_with_format:
  in: "!21.mini!"
  out: "<p>[make_image id:|21| images:true size:|mini| style:||]</p>"
  
image_title:
  in: "!12/!"
  out: "<p>[make_image id:|12| images:true style:|| title:||]</p>"

image_custom_title:
  in: "!12/this is some text!"
  out: "<p>[make_image id:|12| images:true style:|| title:|this is some text|]</p>"

image_custom_title_with_markup:
  in: "!12/this is *some* text!"
  out: "<p>[make_image id:|12| images:true style:|| title:|this is <strong>some</strong> text|]</p>"
  
image_with_link:
  in: "!12.pv!:12"
  out: "<p>[make_image id:|12| images:true link:|12| size:|pv| style:||]</p>"
  
image_with_http_link:
  in: "!12.pv!:http://www.example.org"
  out: "<p>[make_image id:|12| images:true link:|http://www.example.org| size:|pv| style:||]</p>"

image_with_ref:
  in: "!http://www.example.org/images/test.jpg!"
  out: "<p><img src=\"http://www.example.org/images/test.jpg\" alt=\"\" /></p>"

link_with_title:
  in: '"this is a title":23'
  out: '<p>[make_link id:|23| title:|this is a title|]</p>'

link_no_title:
  in: '"":23'
  out: '<p>[make_link id:|23| title:||]</p>'
  
wiki_link:
  in: "why use ?ruby? ?"
  out: "<p>why use [make_wiki_link title:|ruby|] ?</p>"

wiki_link_with_trailing_dot:
  in: "I love ?ruby?."
  out: "<p>I love [make_wiki_link title:|ruby|].</p>"
  
wiki_link_url:
  in: "why use ?ruby?:http://en.wikipedia.org/wiki/Ruby_%28programming_language%29 ?"
  out: "<p>why use [make_wiki_link title:|ruby| url:|http://en.wikipedia.org/wiki/Ruby_%28programming_language%29|] ?</p>"
  
wiki_link_url_ending_punctuation:
  in: "why use ?ruby?:http://en.wikipedia.org/wiki/Ruby_%28programming_language%29, or what ?"
  out: "<p>why use [make_wiki_link title:|ruby| url:|http://en.wikipedia.org/wiki/Ruby_%28programming_language%29|], or what ?</p>"

erb_recursive_syntax:
  in: "why <code lang='erb'> this <%= puts \"hello\" %> is ok</code>"
  out: "/why <pre><code class='erb'>.*<code class='ruby'>.*</code>.*</span> is ok</code></pre>/"
  
benchmark:
  in: |
   h3. design should be fun

   It' is very exciting to think of a new templating language. One of the goals we have is to make the template easily editable by graphic designers. A designer will have to add some ?Lorem ipsum? placeholder text, eventually copied from "lipsum":http://lipsum.com/. If he doesn't, this is what happens :

   The 'zafu' template

   <code lang='zafu'><h2><z:show attr=':v_title'/></h2>
     <z:children>
       <ul>
         <z:each><li><z:link/></li></z:each>
       </ul>
     </z:children>
   </code>

   renders like this in a web browser or wysiwyg editor :

   <div class='box' style='font-size:small; padding:0;'>
   <h3 style='margin:0;'><z:show attr=':v_title'/></h3>
     <z:children>
       <ul>
         <z:each><li><z:link/></li></z:each>
       </ul>
     </z:children>
   </div>

   This is not terrible to create stunning designs.

   The same example with placeholder text instead of empty tags (title, link):

   <code lang='zafu' class='large'><h3><z:show attr=':v_title'>qui dolorem</z:show></h3>
     <z:children>
       <ul>
         <z:each><li><z:link><a href='#'>ipsum quia</a></z:link></li></z:each>
         <z:each><li><z:link><a href='#'>dolor sit</a></z:link></li></z:each>
       </ul>
     </z:children>
   </code>

   becomes :

   <div class='box' style='font-size:small;'>
   <h3 style='margin:0;'><z:show attr=':v_title'>qui dolorem</z:show></h3>
     <z:children>
       <ul>
         <z:each><li><z:link><a href='#'>ipsum quia</a></z:link></li></z:each>
         <z:each><li><z:link><a href='#'>dolor sit</a></z:link></li></z:each>
       </ul>
     </z:children>
   </div>

   *Great !* We can test the template without rendering it ! Now our rendering system must be clever enough to remove the content between 'block' tags (title, link, ...). This seems easy, but what about the multiple 'each' to create the list ? We could skip the second 'each', but this would be bad if we want to render a table of contents followed by the content itself :

   <code lang='zafu'><z:each><z:show attr=':v_title'/></z:each>
   <z:each><h3><z:show attr=':v_title'/></h3>
   <div><z:text/></div></z:each>
   </code>

   We will use two tricks to skip content. The @zafu|<z:lorem>@ tag, will remove any content it contains during compilation, and the @zafu|<z:each lorem='true'>@ parameter will transform any block tag (each, children, ...) into a dummy. The first example would then be written as : 

   <code lang='zafu' class='large'><h2><z:show attr=':v_title'>qui dolorem</z:show></h2> 
     <z:children> 
       <ul> 
         <z:each><li><z:link><a href='#'>ipsum quia</a></z:link></li></z:each> 
         <z:each lorem='true'><li> ... ipsum quia ... </li></z:each> 
         <z:lorem><li><a href='#'>adipisci velit</a></li></z:lorem> 
       </ul> 
     </z:children> 
   </code> 

   Which compiles as : 

   <code lang='erb' class='large'> 
   <h3><%= @node.send(:version)[:title] %></h3> 
     <% if var1 = @node.children -%> 
       <ul> 
         <% var1.each do |var2| -%><li><%= make_link(var2) %></li><% end -%> 
       </ul> 
     <% end -%> 
   </code> 

   Notice how all the _lorem ipsum_ blah blah has been simply stripped off.

   h3. templates should include reusable code

   Let's follow the conventions used in other programming languages. Inserting some template into another is done with the @include@ tag :

   <code lang='zafu'><z:include template='menu'/>
   or
   <z:include template='menu/sub'/>
   </code>


   Templates specified by their name or by a path without a leading slash are found in the current template's folder :


   !<.22.full!

   * _default_ if rendering __default.html_
   * _menu_ if rendering __menu.html_
   * _funny_ if rendering __funny.html_

   When specifying a template by a path starting with a slash (@zafu|<z:include template='/funny'/>@), the template is searched as a direct child of the _templates_ root node where all the template objects *must* live.


   h3(clear). sharing templates

   Visitors can *download* any template node (if they have read access to the node). When downloading a template, Zena creates a tar archive containing the template and all it's descendants. For example, downloading _default_ would provide a folder called _default_ containing the following files :

   !<.23.full!

   The main file must have the same name as the folder with a leading underscore.

   *Uploading* is like creating/editing a document: you upload the tar archive and all the children nodes are created/updated for you (I still have to implement all this.. but that's the goal).

   You can *edit* the template just like any other node (templates are just text).

   h3. css ?

   CSS files are just a special kind of templates. Tags to link to a stylesheet use the same naming conventions as with the include tag.

   <code lang='zafu' class='large'><z:stylesheet template='/funny/fun'/>
   will become
   <link rel='stylesheet' type='text/css' href='/stylesheets/funny_fun.css'/></code>

   h3. Code, monkey !

   This looks great on the 'paper', we hope it will be even more fun in real.

   *PS:* the 'download/upload' mechanism used for templates could be extended to other groups of documents (images to make a gallery for example).

   *PPS:* the template should be compiled once for every language to reduce translation calls when rendering. It could be store as 'default.en.rhtml', 'default.fr.rhtml', ...
